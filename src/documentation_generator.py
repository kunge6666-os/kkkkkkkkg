"""
é¡¹ç›®æ–‡æ¡£ç”Ÿæˆæ¨¡å—
ç”Ÿæˆå®Œæ•´çš„é¡¹ç›®æ–‡æ¡£å’Œè¯´æ˜æ–‡ä»¶
"""
import os
import shutil
from pathlib import Path
import pandas as pd

from config import PROCESSED_DATA_PATH


class DocumentationGenerator:
    def __init__(self):
        self.project_structure = {}

    def generate_readme(self, project_metrics, integrated_results):
        """
        ç”Ÿæˆé¡¹ç›®READMEæ–‡æ¡£
        """
        print("=== ç”ŸæˆREADMEæ–‡æ¡£ ===")

        basic = project_metrics.get('basic', {})
        kpis = project_metrics.get('kpis', {})

        readme_content = f"""
# ç”µå•†ç”¨æˆ·è¡Œä¸ºåˆ†æé¡¹ç›®

## é¡¹ç›®ç®€ä»‹
è¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç”µå•†ç”¨æˆ·è¡Œä¸ºæ•°æ®åˆ†æé¡¹ç›®ï¼ŒåŸºäºçœŸå®çš„ç”¨æˆ·è¡Œä¸ºæ•°æ®ï¼Œæ„å»ºäº†ä»æ•°æ®æ¸…æ´—åˆ°æœºå™¨å­¦ä¹ é¢„æµ‹çš„å®Œæ•´åˆ†ææµæ°´çº¿ã€‚

## ğŸ“Š é¡¹ç›®äº®ç‚¹
- **å®Œæ•´åˆ†ææµç¨‹**: æ•°æ®æ¸…æ´— â†’ æ¢ç´¢æ€§åˆ†æ â†’ æ·±åº¦æ´å¯Ÿ â†’ æœºå™¨å­¦ä¹ é¢„æµ‹
- **å¤šç»´åº¦åˆ†æ**: ç”¨æˆ·è¡Œä¸ºã€å•†å“è¡¨ç°ã€æ—¶é—´è¶‹åŠ¿ã€è½¬åŒ–æ¼æ–—å…¨è¦†ç›–
- **å·¥ä¸šçº§å®è·µ**: æ¨¡å—åŒ–ä»£ç ã€è‡ªåŠ¨åŒ–æŠ¥å‘Šã€å¯å¤ç°åˆ†æ
- **ä¸šåŠ¡å¯¼å‘**: æ‰€æœ‰åˆ†æç»“æœéƒ½è½¬åŒ–ä¸ºå…·ä½“çš„ä¸šåŠ¡å»ºè®®

## ğŸ¯ æ ¸å¿ƒå‘ç°
- **ç”¨æˆ·è§„æ¨¡**: {basic.get('total_users', 0):,} æ´»è·ƒç”¨æˆ·
- **è½¬åŒ–è¡¨ç°**: {kpis.get('conversion_metrics', {}).get('overall_conversion_rate', 0):.2f}% æ•´ä½“è´­ä¹°è½¬åŒ–ç‡
- **é¢„æµ‹èƒ½åŠ›**: æœªæ¥7å¤©è´­ä¹°é‡é¢„æµ‹å‡†ç¡®ç‡ {kpis.get('forecast_metrics', {}).get('prediction_confidence', 0):.1f}%

## ğŸ—‚ï¸ é¡¹ç›®ç»“æ„
ç”µå•†ç”¨æˆ·è¡Œä¸ºåˆ†æ/
â”œâ”€â”€ data/ # æ•°æ®ç›®å½•
â”‚ â”œâ”€â”€ UserBehavior.csv/ # åŸå§‹æ•°æ®
â”‚ â””â”€â”€ processed/ # å¤„ç†åçš„æ•°æ®
â”œâ”€â”€ notebooks/ # åˆ†æNotebooks
â”‚ â”œâ”€â”€ å¯¼å…¥å’Œè®¾ç½®.ipynb
â”‚ â”œâ”€â”€ ç”¨æˆ·è¡Œä¸ºæ·±åº¦åˆ†æ.ipynb
â”‚ â”œâ”€â”€ å•†å“åˆ†æä¸æ¨èç­–ç•¥.ipynb
â”‚ â”œâ”€â”€ æ—¶é—´åºåˆ—åˆ†æä¸é¢„æµ‹æ¨¡å‹.ipynb
â”‚ â””â”€â”€ é¡¹ç›®æ•´åˆä¸ç»¼åˆæŠ¥å‘Š.ipynb
â”œâ”€â”€ src/ # æºä»£ç 
â”‚ â”œâ”€â”€ data_loader.py # æ•°æ®åŠ è½½
| â”œâ”€â”€ config.py # è·¯å¾„é…ç½®
â”‚ â”œâ”€â”€ data_cleaner.py # æ•°æ®æ¸…æ´—
â”‚ â”œâ”€â”€ analyzer.py # åˆ†ææ¨¡å—
â”‚ â”œâ”€â”€ visualizer.py # å¯è§†åŒ–
â”‚ â”œâ”€â”€ funnel_analyzer.py # è½¬åŒ–æ¼æ–—
â”‚ â”œâ”€â”€ retention_analyzer.py # ç•™å­˜åˆ†æ
â”‚ â”œâ”€â”€ value_analyzer.py # ç”¨æˆ·ä»·å€¼
â”‚ â”œâ”€â”€ product_analyzer.py # å•†å“åˆ†æ
â”‚ â”œâ”€â”€ recommender.py # æ¨èç³»ç»Ÿ
â”‚ â”œâ”€â”€ time_series_analyzer.py # æ—¶é—´åºåˆ—
â”‚ â”œâ”€â”€ predictive_model.py # é¢„æµ‹æ¨¡å‹
â”‚ â”œâ”€â”€ project_integrator.py # é¡¹ç›®æ•´åˆ
â”‚ â””â”€â”€ documentation_generator.py # æ–‡æ¡£ç”Ÿæˆ
â””â”€â”€ reports/ # æŠ¥å‘Šè¾“å‡º
  â”œâ”€â”€ figures/ # å›¾è¡¨æ–‡ä»¶
  â”œâ”€â”€ analysis_reports/ # åˆ†ææŠ¥å‘Š
  â””â”€â”€ final_reports/ # æœ€ç»ˆæŠ¥å‘Š


text

## ğŸš€ å¿«é€Ÿå¼€å§‹

### ç¯å¢ƒè¦æ±‚
- Python 3.8+
- Jupyter Notebook

### å®‰è£…ä¾èµ–
```bash
pip install -r requirements.txt
è¿è¡Œå®Œæ•´åˆ†æ
æŒ‰é¡ºåºè¿è¡Œnotebooksç›®å½•ä¸‹çš„æ–‡ä»¶:

01_æ•°æ®åŠ è½½ä¸éªŒè¯.ipynb

02_æ•°æ®æ¸…æ´—ä¸ç‰¹å¾å·¥ç¨‹.ipynb

03_ç”¨æˆ·è¡Œä¸ºæ·±åº¦åˆ†æ.ipynb

04_å•†å“åˆ†æä¸æ¨èç­–ç•¥.ipynb

05_æ—¶é—´åºåˆ—åˆ†æä¸é¢„æµ‹æ¨¡å‹.ipynb

06_é¡¹ç›®æ•´åˆä¸ç»¼åˆæŠ¥å‘Š.ipynb

æ•°æ®å‡†å¤‡
é¡¹ç›®ä½¿ç”¨é˜¿é‡Œäº‘å¤©æ± çš„æ·˜å®ç”¨æˆ·è¡Œä¸ºæ•°æ®é›†ï¼Œè¯·ä»ä»¥ä¸‹åœ°å€ä¸‹è½½ï¼š
https://tianchi.aliyun.com/dataset/649

å°†ä¸‹è½½çš„UserBehavior.csvæ–‡ä»¶æ”¾ç½®åœ¨data/raw/ç›®å½•ä¸‹ã€‚

ğŸ“ˆ åˆ†ææ¨¡å—
1. æ•°æ®é¢„å¤„ç†
æ•°æ®è´¨é‡æ£€æŸ¥ä¸æ¸…æ´—

ç‰¹å¾å·¥ç¨‹ä¸æ•°æ®è½¬æ¢

æ—¶é—´ç‰¹å¾æå–

2. ç”¨æˆ·è¡Œä¸ºåˆ†æ
ç”¨æˆ·æ´»è·ƒåº¦åˆ†æ

è½¬åŒ–æ¼æ–—åˆ†æ

ç”¨æˆ·ç•™å­˜åˆ†æ

RFMç”¨æˆ·ä»·å€¼åˆ†å±‚

3. å•†å“åˆ†æ
å•†å“çƒ­åº¦åˆ†æ

ç±»ç›®è¡¨ç°åˆ†æ

å•†å“å…³è”è§„åˆ™æŒ–æ˜

4. æ¨èç³»ç»Ÿ
ååŒè¿‡æ»¤ç®—æ³•å®ç°

ç”¨æˆ·ä¸ªæ€§åŒ–æ¨è

æ¨èæ•ˆæœè¯„ä¼°

5. æ—¶é—´åºåˆ—åˆ†æ
è¶‹åŠ¿ä¸å­£èŠ‚æ€§åˆ†æ

æœºå™¨å­¦ä¹ é¢„æµ‹æ¨¡å‹

æœªæ¥ä¸šåŠ¡é¢„æµ‹

6. é¡¹ç›®æ•´åˆ
ç»¼åˆæ•°æ®çœ‹æ¿

ä¸šåŠ¡KPIè®¡ç®—

æœ€ç»ˆæŠ¥å‘Šç”Ÿæˆ

ğŸ“Š è¾“å‡ºæˆæœ
åˆ†ææŠ¥å‘Š
æ¢ç´¢æ€§åˆ†ææŠ¥å‘Š

ç”¨æˆ·è¡Œä¸ºæ·±åº¦åˆ†ææŠ¥å‘Š

å•†å“åˆ†æä¸æ¨èç­–ç•¥æŠ¥å‘Š

æ—¶é—´åºåˆ—åˆ†æä¸é¢„æµ‹æŠ¥å‘Š

æœ€ç»ˆç»¼åˆé¡¹ç›®æŠ¥å‘Š

æ•°æ®å¯è§†åŒ–
äº¤äº’å¼æ•°æ®å›¾è¡¨

ç»¼åˆæ•°æ®çœ‹æ¿

ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§

å¯å¤ç”¨ä»£ç 
æ¨¡å—åŒ–åˆ†æå‡½æ•°

è‡ªåŠ¨åŒ–æŠ¥å‘Šç”Ÿæˆ

æœºå™¨å­¦ä¹ æµæ°´çº¿

ğŸ› ï¸ æŠ€æœ¯æ ˆ
æ•°æ®å¤„ç†: Pandas, NumPy

æ•°æ®å¯è§†åŒ–: Matplotlib, Seaborn

æœºå™¨å­¦ä¹ : Scikit-learn

æ—¶é—´åºåˆ—: Statsmodels

ç»Ÿè®¡åˆ†æ: SciPy

å¼€å‘ç¯å¢ƒ: Jupyter Notebook

ğŸ“ ä½¿ç”¨è¯´æ˜
æ¯ä¸ªåˆ†ææ¨¡å—éƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œå¯ä»¥å•ç‹¬è¿è¡Œæˆ–æŒ‰é¡ºåºè¿è¡Œè·å¾—å®Œæ•´åˆ†æã€‚æ‰€æœ‰æ¨¡å—éƒ½æä¾›äº†è¯¦ç»†çš„ä»£ç æ³¨é‡Šå’Œä¸šåŠ¡è§£é‡Šã€‚

ğŸ¤ è´¡çŒ®æŒ‡å—
æ¬¢è¿æäº¤Issueå’ŒPull Requestæ¥æ”¹è¿›è¿™ä¸ªé¡¹ç›®ï¼

ğŸ“„ è®¸å¯è¯
æœ¬é¡¹ç›®é‡‡ç”¨MITè®¸å¯è¯ã€‚

ğŸ“ è”ç³»æ–¹å¼
å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·é€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»ï¼š

é‚®ç®±: 3379608705@qq.com

GitHub: https://github.com/kunge6666-os/kkkkkkkkg

æœ€åæ›´æ–°: {pd.Timestamp.now().strftime('%Y-%m-%d')}
"""


        readme_path = Path.cwd() / "README.md"
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(readme_content)

        print(f"âœ… READMEæ–‡æ¡£å·²ç”Ÿæˆ: {readme_path}")
        return readme_path


    def generate_technical_documentation(self, project_metrics):
        """
        ç”ŸæˆæŠ€æœ¯æ–‡æ¡£
        """
        print("ç”ŸæˆæŠ€æœ¯æ–‡æ¡£...")

        tech_doc = f"""
    æŠ€æœ¯æ–‡æ¡£
    ç³»ç»Ÿæ¶æ„
æ•°æ®æµæ¶æ„
æ•°æ®æº: åŸå§‹CSVæ–‡ä»¶

æ•°æ®å¤„ç†: Pandasæ•°æ®æ¸…æ´—å’Œç‰¹å¾å·¥ç¨‹

åˆ†æå¼•æ“: æ¨¡å—åŒ–åˆ†æå‡½æ•°

å¯è§†åŒ–å±‚: Matplotlib/Seabornå›¾è¡¨

æŠ¥å‘Šç”Ÿæˆ: è‡ªåŠ¨åŒ–MarkdownæŠ¥å‘Š

æ¨¡å—è®¾è®¡
é¡¹ç›®é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œæ¯ä¸ªåˆ†æåŠŸèƒ½éƒ½æ˜¯ç‹¬ç«‹çš„Pythonæ¨¡å—ï¼Œä¾¿äºç»´æŠ¤å’Œå¤ç”¨ã€‚

æ ¸å¿ƒç®—æ³•
1. RFMç”¨æˆ·åˆ†å±‚
python
# åŸºäºç”¨æˆ·æœ€è¿‘è´­ä¹°æ—¶é—´(R)ã€è´­ä¹°é¢‘æ¬¡(F)ã€è´­ä¹°é‡‘é¢(M)è¿›è¡Œåˆ†å±‚
R_Score = ç”¨æˆ·æœ€è¿‘è´­ä¹°æ—¶é—´è¯„åˆ†
F_Score = ç”¨æˆ·è´­ä¹°é¢‘æ¬¡è¯„åˆ†  
M_Score = ç”¨æˆ·ä»·å€¼è¯„åˆ†
ç”¨æˆ·åˆ†å±‚ = f(R_Score, F_Score, M_Score)
2. ååŒè¿‡æ»¤æ¨è
python
# åŸºäºå•†å“çš„ååŒè¿‡æ»¤
ç”¨æˆ·-å•†å“çŸ©é˜µ = æ„å»ºäº¤äº’çŸ©é˜µ
å•†å“ç›¸ä¼¼åº¦ = cosine_similarity(ç”¨æˆ·-å•†å“çŸ©é˜µ.T)
æ¨èåˆ†æ•° = Î£(ç”¨æˆ·å†å²å…´è¶£ Ã— å•†å“ç›¸ä¼¼åº¦)
3. æ—¶é—´åºåˆ—é¢„æµ‹
python
# ä½¿ç”¨éšæœºæ£®æ—è¿›è¡Œé¢„æµ‹
ç‰¹å¾ = [æ»åç‰¹å¾, æ»šåŠ¨ç»Ÿè®¡, æ—¶é—´ç‰¹å¾]
æ¨¡å‹ = RandomForestRegressor()
é¢„æµ‹ = æ¨¡å‹.predict(ç‰¹å¾)
æ€§èƒ½ä¼˜åŒ–
å†…å­˜ç®¡ç†
ä½¿ç”¨åˆé€‚çš„æ•°æ®ç±»å‹å‡å°‘å†…å­˜å ç”¨

å¤§æ•°æ®é›†é‡‡ç”¨æŠ½æ ·åˆ†æ

åˆ†å—å¤„ç†å¤§è§„æ¨¡æ•°æ®

è®¡ç®—ä¼˜åŒ–
å‘é‡åŒ–æ“ä½œæ›¿ä»£å¾ªç¯

ä½¿ç”¨å†…ç½®èšåˆå‡½æ•°

ç¼“å­˜ä¸­é—´ç»“æœ

æ‰©å±•æŒ‡å—
æ·»åŠ æ–°çš„åˆ†ææ¨¡å—
åœ¨src/ç›®å½•ä¸‹åˆ›å»ºæ–°çš„Pythonæ–‡ä»¶

å®ç°åˆ†æç±»å’Œæ–¹æ³•

åœ¨ä¸»Notebookä¸­é›†æˆæ–°æ¨¡å—

æ›´æ–°æ–‡æ¡£å’ŒæŠ¥å‘Š

è‡ªå®šä¹‰å¯è§†åŒ–
ä¿®æ”¹visualizer.pyä¸­çš„å›¾è¡¨æ ·å¼

æ·»åŠ æ–°çš„å›¾è¡¨ç±»å‹

è°ƒæ•´é¢œè‰²ä¸»é¢˜å’Œå¸ƒå±€

æ•…éšœæ’é™¤
å¸¸è§é—®é¢˜
å†…å­˜ä¸è¶³: å‡å°‘æ ·æœ¬å¤§å°æˆ–ä½¿ç”¨åˆ†å—å¤„ç†

æ•°æ®æ ¼å¼é”™è¯¯: æ£€æŸ¥CSVæ–‡ä»¶æ ¼å¼å’Œç¼–ç 

ä¾èµ–åŒ…å†²çª: ä½¿ç”¨requirements.txtç¡®ä¿ç‰ˆæœ¬ä¸€è‡´

è°ƒè¯•æŠ€å·§
ä½¿ç”¨Jupyter Notebookè¿›è¡Œäº¤äº’å¼è°ƒè¯•

æ·»åŠ è¯¦ç»†çš„æ—¥å¿—è¾“å‡º

ä½¿ç”¨å°æ ·æœ¬æ•°æ®è¿›è¡Œæµ‹è¯•
"""



        tech_doc_path = PROCESSED_DATA_PATH.parent.parent / "reports" / "final_reports" / "æŠ€æœ¯æ–‡æ¡£.md"
        with open(tech_doc_path, 'w', encoding='utf-8') as f:
            f.write(tech_doc)

        print(f"âœ… æŠ€æœ¯æ–‡æ¡£å·²ç”Ÿæˆ: {tech_doc_path}")
        return tech_doc_path


    def create_project_package(self):
        """
        åˆ›å»ºé¡¹ç›®æ‰“åŒ…æ–‡ä»¶
        """


        print("=== åˆ›å»ºé¡¹ç›®æ‰“åŒ… ===")


        # åˆ›å»ºå‘å¸ƒç›®å½•
        release_dir = Path.cwd() / "release"
        release_dir.mkdir(exist_ok=True)

        # éœ€è¦åŒ…å«çš„æ–‡ä»¶å’Œç›®å½•
        include_dirs = ['src', 'config', 'reports']
        include_files = ['README.md', 'requirements.txt']

        # å¤åˆ¶æ–‡ä»¶
        for dir_name in include_dirs:
            src_dir = Path.cwd() / dir_name
            dst_dir = release_dir / dir_name
            if src_dir.exists():
                if dst_dir.exists():
                    shutil.rmtree(dst_dir)
                shutil.copytree(src_dir, dst_dir)

        for file_name in include_files:
            src_file = Path.cwd() / file_name
            dst_file = release_dir / file_name
            if src_file.exists():
                shutil.copy2(src_file, dst_file)

        # åˆ›å»ºnotebooksçš„ç®€åŒ–ç‰ˆæœ¬ï¼ˆå¯é€‰ï¼‰
        notebooks_src = Path.cwd() / "notebooks"
        notebooks_dst = release_dir / "notebooks"
        if notebooks_src.exists():
            shutil.copytree(notebooks_src, notebooks_dst)

        print(f"âœ… é¡¹ç›®æ‰“åŒ…å®Œæˆ: {release_dir}")
        return release_dir
#åˆ›å»ºå…¨å±€å®ä¾‹
doc_generator = DocumentationGenerator()